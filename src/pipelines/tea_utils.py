#
# Copyright 2022-2023 Universidad Complutense de Madrid
#
# This file contains code generated by N. Cardiel for the students of the
# Astrophysics Master at UCM
#
# Version: Feb 22, 2023 @13:25
#
# SPDX-License-Identifier: GPL-3.0+
#

from astropy.io import fits
from astropy.nddata import CCDData
import astropy.units as u
from datetime import datetime
import matplotlib.patches as patches
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import numpy.ma as ma
from pathlib import Path
from scipy import ndimage
from tqdm.notebook import tqdm


def ctext(s=None, 
          fg=None, 
          bg=None, 
          under=False,
          rev=False,
          bold=False):
    """Return coloured string using ANSI Escape Sequences

    See ANSI Escape values in:
    https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797

    Parameters
    ----------
    s : object
        Object to be displayed
    fg : str
        Foreground colour.
    bg : str
        Background colour.
    under : bool
        If True, add underline style.
    rev : bool
        If True, add reverse style.
    bold : bool
        If True, add bold style

    """

    colour = {
        'black': 0,
        'red': 1,
        'green': 2,
        'yellow': 3,
        'blue': 4,
        'magenta': 5,
        'cyan': 6,
        'white': 7,
        'default': 9,
        'reset': 0
    }

    if s is None:
        print(f'Available colours: {list(colour.keys())}')
        return

    # foreground
    if fg is not None:
        fg = fg.lower()
        if fg not in colour:
            raise ValueError(f'Unexpected foreground colour: {fg}')

    # background
    if bg is not None:
        bg = bg.lower()
        if bg not in colour:
            raise ValueError(f'Unexpected background colour: {bg}')

    style_list = []
    if under:
        style_list.append('\x1B[4m')
    if rev:
        style_list.append('\x1B[7m')
    if bold:
        style_list.append('\x1B[1m')

    if fg is not None:
        style_list.append(f'\x1B[3{colour[fg]}m')

    if bg is not None:
        style_list.append(f'\x1B[4{colour[bg]}m')

    final_style = ''.join(style_list)

    return f'{final_style}{s}\x1B[0m'


def tea_imshow(fig=None, ax=None, data=None,
               crpix1=1, crval1=None, cdelt1=None, cunit1=None, cunitx=u.Angstrom,
               xlabel=None, ylabel=None, title=None,
               colorbar=True, cblabel='Number of counts',
               **kwargs):
    """Call imshow() with color bar and default labels.

    If crpix1, crval1, cdelt1 and cunit1 are not None, a wavelengh
    scale is also displayed. In this case, the colorbar is not shown
    because there is a conflict (to be solved).

    Parameters
    ----------
    fig : matplotlib.figure.Figure
        Figure object.
    ax : matplotlib.axes.Axes
        Axes object.
    data : numpy array
        2D array to be displayed.
    crpix1 : astropy.units.Quantity
        Float number providing the CRPIX1 value: the reference pixel
        for which CRVAL1 is given.
    crval1 : astropy.units.Quantity
        Float number providing the CRVAL1 value: wavelength at the
        center of the first pixel.
    cdelt1 : astropy.units.Quantity
        Float number providing CDELT1 value: wavelength increment
        per pixel.
    cunit1 : astropy.units.Quantity
        Float number providing CUNIT1: the units employed in the
        wavelength calibration.
    cunitx : astropy.units.Quantity
        Units employed to display the wavelength scale. It can be
        different from cunit1.
    xlabel : str or None
        X label.
    ylabel : str or None
        Y label.
    title : str or None
        Plot title.
    colorbar : bool
        If True, display color bar.
    cblabel : str
        Color bar label.

    Return
    ------
    img : matplotlib AxesImage
        Instance returned by ax.imshow()

    """

    if xlabel is None:
        xlabel = 'X axis (array index)'

    if ylabel is None:
        ylabel = 'Y axis (array index)'

    if crpix1 is not None and crval1 is not None and cdelt1 is not None and cunit1 is not None:
        if 'extent' in kwargs:
            raise ValueError('extent parameter can not be used with a wavelength calibration scale')
        if 'aspect' in kwargs:
            raise ValueError('aspect parameter can not be used with a wavelength calibration scale')
        naxis2, naxis1 = data.shape
        xmin, xmax = -0.5, naxis1 - 0.5
        ymin, ymax = -0.5, naxis2 - 0.5
        xminwv = crval1 + (xmin * u.pixel - crpix1 + 1 * u.pixel) * cdelt1
        xmaxwv = crval1 + (xmax * u.pixel - crpix1 + 1 * u.pixel) * cdelt1
        extent = [xminwv.to(cunitx).value, xmaxwv.to(cunitx).value, ymin, ymax]
        xlabel = f'Wavelength ({cunitx})'
        aspect = 'auto'
    else:
        extent = None
        if 'aspect' in kwargs:
            aspect = kwargs['aspect']
            del kwargs['aspect']
        else:
            aspect = None

    if 'origin' not in kwargs and 'interpolation' not in kwargs:
        img = ax.imshow(data, origin='lower', interpolation='nearest', extent=extent, aspect=aspect, **kwargs)
    elif 'origin' not in kwargs:
        img = ax.imshow(data, origin='lower', extent=extent, aspect=aspect, **kwargs)
    elif 'interpolation' not in kwargs:
        img = ax.imshow(data, interpolation='nearest', extent=extent, aspect=aspect, **kwargs)
    else:
        img = ax.imshow(data, extent=extent, aspect=aspect, **kwargs)

    if xlabel is not None:
        ax.set_xlabel(xlabel)
    if ylabel is not None:
        ax.set_ylabel(ylabel)
    if title is not None:
        ax.set_title(title)

    if colorbar:
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.05)
        fig.colorbar(img, cax=cax, label=cblabel)


def zscale(image, factor=0.25):
    '''Compute z1 and z2 cuts in a similar way to Iraf.
    
    If the total number of pixels is less than 10, the function simply 
    returns the minimum and the maximum values.

    Parameters
    ----------
    image : np.ndarray
        Image array.
    factor : float
        Factor.

    Returns
    -------
    z1 : float
        Background value.
    z2 : float
        Foreground value.

    '''

    # protections
    if not isinstance(image, np.ndarray):
        raise ValueError('image must be a numpy.ndarray')

    npixels = image.size

    if npixels < 10:
        z1 = np.min(image)
        z2 = np.max(image)
    else:
        q000, q375, q500, q625, q1000 = np.percentile(image, [00.0, 37.5, 50.0, 62.5, 100.0])
        zslope = (q625-q375)/(0.25*npixels)
        z1 = q500-(zslope*npixels/2)/factor
        z1 = max(z1, q000)
        z2 = q500+(zslope*npixels/2)/factor
        z2 = min(z2, q1000)
    
    return z1, z2


def robust_std(x, debug=False):
    """Compute a robust estimator of the standard deviation

    See Eq. 3.36 (page 84) in Statistics, Data Mining, and Machine
    in Astronomy, by Ivezic, Connolly, VanderPlas & Gray

    Parameters
    ----------
    x : 1d numpy array, float
        Array of input values which standard deviation is requested.
    debug : bool
        If True display computed values

    Returns
    -------
    sigmag : float
        Robust estimator of the standar deviation
    """

    x = np.asarray(x)

    # compute percentiles and robust estimator
    q25 = np.percentile(x, 25)
    q75 = np.percentile(x, 75)
    sigmag = 0.7413 * (q75 - q25)

    if debug:
        print('debug|robust_std -> q25......................:', q25)
        print('debug|robust_std -> q75......................:', q75)
        print('debug|robust_std -> Robust standard deviation:', sigmag)

    return sigmag


def tea_statsummary(x=None, rm_nan=False, show=True):
    """Compute basic statistical parameters.

    Parameters
    ----------
    x : numpy array or None
        Input array with values which statistical properties are 
        requested.
    rm_nan : bool
        If True, filter out NaN values before computing statistics.
    show : bool
        If True display computed values.

    Returns
    -------
    result : Python dictionary
        Number of points, minimum, percentile 25, percentile 50
        (median), mean, percentile 75, maximum, standard deviation,
        robust standard deviation, percentile 15.866 (equivalent
        to -1 sigma in a normal distribution) and percentile 84.134
        (+1 sigma). This result if returned only if return_output=True.

    """

    # protections
    if x is None:
        return ['npoints', 'minimum', 'maximum', 
                'mean', 'median', 'std', 'robust_std', 
                'percentile16', 'percentile25', 'percentile75', 'percentile84'] 

    if isinstance(x, np.ndarray):
        xx = np.copy(x.flatten())
    else:
        if isinstance(x, list):
            xx = np.array(x)
        else:
            raise ValueError('x=' + str(x) + ' must be a numpy.ndarray')

    # filter out NaN's
    if rm_nan:
        xx = xx[np.logical_not(np.isnan(xx))]

    # compute basic statistics
    npoints = len(xx)
    ok = npoints > 0
    result = {
        'npoints': npoints,
        'minimum': np.min(xx) if ok else 0,
        'percentile25': np.percentile(xx, 25) if ok else 0,
        'median': np.percentile(xx, 50) if ok else 0,
        'mean': np.mean(xx) if ok else 0,
        'percentile75': np.percentile(xx, 75) if ok else 0,
        'maximum': np.max(xx) if ok else 0,
        'std': np.std(xx) if ok else 0,
        'robust_std': robust_std(xx) if ok else 0,
        'percentile16': np.percentile(xx, 15.86553) if ok else 0,
        'percentile84': np.percentile(xx, 84.13447) if ok else 0
    }

    if show:
        print('>>> =============================================')
        print('>>> STATISTICAL SUMMARY:')
        print('>>> ---------------------------------------------')
        print('>>> Number of points.........:', result['npoints'])
        print('>>> Minimum..................:', result['minimum'])
        print('>>> 1st Quartile.............:', result['percentile25'])
        print('>>> Median...................:', result['median'])
        print('>>> Mean.....................:', result['mean'])
        print('>>> 3rd Quartile.............:', result['percentile75'])
        print('>>> Maximum..................:', result['maximum'])
        print('>>> ---------------------------------------------')
        print('>>> Standard deviation.......:', result['std'])
        print('>>> Robust standard deviation:', result['robust_std'])
        print('>>> 0.1586553 percentile.....:', result['percentile16'])
        print('>>> 0.8413447 percentile.....:', result['percentile84'])
        print('>>> =============================================')

    return result


def tea_ifc_statsummary(ifc, directory, region=None):
    """Include statistical summary in ImageFileCollection object.

    Parameters
    ----------
    ifc : ImageFileCollection object
        Instance of ImageFileCollection.
    directory : Path object
        Directory where images are stored.
    region : SliceRegion2D instance or None
        Region where the statistical summary will be computed. 
        If None the whole data array is employed.

    Returns
    -------
    summary : Astropy Table
        Updated table including the statistical measurements.

    """

    if region is not None:
        if not isinstance(region, SliceRegion2D):
            msg = f'region: {region} must be a SliceRegion2D instance'
            raise ValueError(msg)

    summary = ifc.summary.copy()

    for colname in tea_statsummary():
        # if the column already exists, remove it
        if colname in summary.columns:
            summary.remove_column(colname)
        # create column (initialise to 0)
        if colname == 'npoints':
            summary[colname] = np.zeros(len(summary), dtype=int)
            summary[colname].info.format = 'd'
        else:
            summary[colname] = np.zeros(len(summary))
            summary[colname].info.format = '.3f'
        
    for i, filename in enumerate(tqdm(summary['file'])):
        data = fits.getdata(directory / Path(filename).name)
        naxis2, naxis1 = data.shape
        region_fullframe = SliceRegion2D(np.s_[0:naxis2, 0:naxis1], 
                                         mode='python')
        if region is None:
            region = region_fullframe
        else:
            if not region.within(region_fullframe):
                msg = f'Region for file {filename!r} {region!r} outside full frame ' \
                      f'{region_fullframe!r}'
                raise ValueError(msg)
        result = tea_statsummary(data[region.python], show=False)
        for key, value in result.items():
            summary[key][i] = value

    summary.region = region

    return summary


def tea_draw_rectangle(ax, image_data, x1, x2, y1, y2, color='white', 
                       text=False, ndigits=1, fontsize=15):
    """Auxiliary function to display (mean, std) in a rectangle.

    The mean and standard deviation are computed in the rectangle
    defined by x1, x2, y1, and y2.

    Parameters
    ----------
    ax : Axes
        Instance of matplotlib.axes.Axes.
    image_data : 2d numpy array
        Image where the statistical anaylisis will be performed.
    x1 : int
        Lower image index (column number).
    x2 : int
        Upper image index (column number).
    y1 : int
        Lower image index (row number).
    y2 : int
        Upper image index (row number).
    color : str
        Color for text labels.
    text : bool
        If True, display labels with information.
    ndigits : int
        Number of decimal digits.
    fontsize : int
       Size fo text font.

    Returns
    -------
    mean : float
        Mean value computed in the requested image rectangle.
    std : float
        Standard deviation computed in the requested image rectangle.

    """

    mean = image_data[y1:y2, x1:x2].mean()
    std = image_data[y1:y2, x1:x2].std()

    ax.plot((x1, x1), (y1, y2), color, lw=1)
    ax.plot((x2, x2), (y1, y2), color, lw=1)
    ax.plot((x1, x2), (y1, y1), color, lw=1)
    ax.plot((x1, x2), (y2, y2), color, lw=1)

    if text:
        ax.text((x1+x2)/2, y1+(y2-y1)/8, 
                '{:.{prec}f}'.format(mean, prec=ndigits), 
                ha='center', va='center', color=color, fontsize=fontsize)        
        ax.text((x1+x2)/2, y2-(y2-y1)/8,
                '{:.{prec}f}'.format(std, prec=ndigits), 
                ha='center', va='top', color=color, fontsize=fontsize)

    return mean, std


def tea_avoid_astropy_warnings(avoid_warnings):
    """Auxiliary function to help disable astropy warnings

    Parameters
    ----------
    avoid_warnings : bool
        If True, disable the warnings.

    """

    if avoid_warnings:
        import warnings
        warnings.resetwarnings()
        warnings.filterwarnings('ignore', category=UserWarning, append=True)
        from astropy.utils.exceptions import AstropyWarning
        warnings.simplefilter('ignore', AstropyWarning)


class SliceRegion1D:
    """Store indices for slicing of 1D regions.
    
    The attributes .python and .fits provide the indices following
    the Python and the FITS convention, respectively.
    
    """
    
    def __init__(self, region, mode=None):
        if isinstance(region, slice):
            pass
        else:
            raise ValueError(f'Object {region} of type {type(region)} is not a slice') 
                             
        if region.step not in [1, None]:
            raise ValueError(f'This class {self.__class__.__name__} '
                             'does not handle step != 1')
                             
        errmsg = f'Invalid mode={mode}. Only "FITS" or "Python" (case insensitive) are valid'
        if mode is None:
            raise ValueError(errmsg)
        self.mode = mode.lower()
                             
        if self.mode == 'fits':
            if region.stop < region.start:
                raise ValueError(f'Invalid {region!r}')
            self.fits = region
            self.python = slice(region.start-1, region.stop)
        elif self.mode == 'python':
            if region.stop <= region.start:
                raise ValueError(f'Invalid {region!r}')
            self.fits = slice(region.start+1, region.stop)
            self.python = region
        else:
            raise ValueError(errmsg)

    def __eq__(self, other):
        return self.fits == other.fits and self.python == other.python

    def __repr__(self):
        if self.mode == 'fits':
            return (f'{self.__class__.__name__}('
                    f'{self.fits!r}, mode="fits")')
        else:
            return (f'{self.__class__.__name__}('
                    f'{self.python!r}, mode="python")')

    def within(self, other):
        if isinstance(other, self.__class__):
            pass
        else:
            raise ValueError(f'Object {other} of type {type(other)} is not a {self.__class__.__name__}')
        region = self.python
        region_other = other.python
        if region.start < region_other.start:
            return False
        if region.stop > region_other.stop:
            return False
        return True
                     

class SliceRegion2D:
    """Store indices for slicing of 2D regions.

    The attributes .python and .fits provide the indices following
    the Python and the FITS convention, respectively.

    """

    def __init__(self, region, mode=None):
        if len(region) != 2:
            raise ValueError(f'This class {self.__class__.__name__} '
                             'only handles 2D regions')

        s1, s2 = region
        for item in [s1, s2]:
            if isinstance(item, slice):
                pass
            else:
                raise ValueError(f'Object {item} of type {type(item)} is not a slice')

        if s1.step not in [1, None] or s2.step not in [1, None]:
            raise ValueError(f'This class {self.__class__.__name__} '
                             'does not handle step != 1')

        errmsg = f'Invalid mode={mode}. Only "FITS" or "Python" (case insensitive) are valid'
        if mode is None:
            raise ValueError(errmsg)
        self.mode = mode.lower()

        if self.mode == 'fits':
            if s1.stop < s1.start:
                raise ValueError(f'Invalid {s1!r}')
            if s2.stop < s2.start:
                raise ValueError(f'Invalid {s2!r}')
            self.fits = region
            self.python = slice(s2.start-1, s2.stop), slice(s1.start-1, s1.stop)
        elif self.mode == 'python':
            if s1.stop <= s1.start:
                raise ValueError(f'Invalid {s1!r}')
            if s2.stop <= s2.start:
                raise ValueError(f'Invalid {s2!r}')
            self.fits = slice(s2.start+1, s2.stop), slice(s1.start+1, s1.stop)
            self.python = region
        else:
            raise ValueError(errmsg)

        s1, s2 = self.fits
        self.fits_section = f'[{s1.start}:{s1.stop}, {s2.start}:{s2.stop}]'

    def __eq__(self, other):
        return self.fits == other.fits and self.python == other.python

    def __repr__(self):
        if self.mode == 'fits':
            return (f'{self.__class__.__name__}('
                    f'{self.fits!r}, mode="fits")')
        else:
            return (f'{self.__class__.__name__}('
                    f'{self.python!r}, mode="python")')

    def within(self, other):
        if isinstance(other, self.__class__):
            pass
        else:
            raise ValueError(f'Object {other} of type {type(other)} is not a {self.__class__.__name__}')

        s1, s2 = self.python
        s1_other, s2_other = other.python
        if s1.start < s1_other.start:
            return False
        if s1.stop > s1_other.stop:
            return False
        if s2.start < s2_other.start:
            return False
        if s2.stop > s2_other.stop:
            return False
        return True


def cr2images(data1, data2=None, ioffx=0, ioffy=0,
              tsigma_peak=10, tsigma_tail=3, maxsize=None,
              list_skipped_regions=None,
              image_region=None,
              median_size=None,
              return_masks=False,
              debug_level=0,
              zoom_region_imshow=None):
    """Remove cosmic rays from differences between 2 images.

    The input images must have the same shape. If only 1 image
    is available, this function computes a second image by
    applying a median filter to the first image.

    Parameters
    ----------
    data1 : numpy array
        First image
    data2 : numpy array
        Second image. If None, a median filtered version of 'data1'
        is employed. In this case, the parameter 'median_size' must
        be properly set.
    ioffx : int
        Integer offset (pixels) to place the second image on top of
        the first image in the horizontal direction (axis=1) in the
        numpy array.
    ioffy : int
        Integer offset (pixels) to place the second image on top of
        the first image in the vertical direction (axis=0) in the
        numpy array.
    tsigma_peak : float
        Times sigma to detect cosmic ray peaks
    tsigma_tail : float
        Times sigma to detect additional pixels affected by cosmic
        rays.
    maxsize : int
        Maximum number of pixels affected by a single cosmic ray.
        Above this number the detection is ignored.
    list_skipped_regions : list or None
        List of SliceRegion2D instances indicating image regions where
        detected cosmic rays will not be removed. The indices refer
        to the location of the regions in data1. This option is not
        compatible with image_region.
    image_region : SliceRegion2D instance or None
        Single instance of SliceRegion2D indicating the region where
        cosmic rays will be detected. The indices refer to the location
        of the region in data1. This option is not compatible
        with list_skipped_regions.
    median_size : tuple of integers
         Shape that is taken from the input array, at every element
         position, to compute the median filter. Note that the tuple
         order correspond to (Yaxis, Xaxis). This is only employed
         when 'data2' is None.
    return_masks : bool
        If True, return the masks with the replaced pixels flagged.
    debug_level : int
        If different from zero, print and display debugging information.
    zoom_region_imshow : SliceRegion2D instance or None
        If not None, display intermediate images, zooming in the
        indicated region.

    Returns
    -------
    data1c : numpy array
        Cleaned first image
    data2c : numpy.array
        Cleaned second image of median filtered version of 'data1' if
        'data2' is None.
    mask_data1c : numpy array
        Mask corresponding to replaced pixels in 'data1' (0: unmodified
        pixels, 1: replaced pixels). This array is returned only it the
        input parameter 'return_masks' is True.
    mask_data2c : numpy array
        Mask corresponding to replaced pixels in 'data2' (0: unmodified
        pixels, 1: replaced pixels). This array is returned only it the
        input parameter 'return_masks' is True.

    """

    if data2 is None:
        if (ioffx != 0) or (ioffy != 0):
            raise ValueError(f'ERROR: ioffx={ioffx} and ioffy={ioffy} must be zero!')
        if median_size is None:
            raise ValueError(f'ERROR: you must specify median_size when only one image is available')
        data2 = ndimage.median_filter(data1, size=median_size)
        single_mode = True
    else:
        single_mode = False

    if list_skipped_regions is not None and image_region is not None:
        raise ValueError('list_skipped_regions and useful_region are incompatible')

    shape1 = data1.shape
    shape2 = data2.shape

    if shape1 != shape2:
        raise ValueError('ERROR: the images have different shape')

    naxis2, naxis1 = shape1

    if abs(ioffx) > naxis1:
        raise ValueError(f'ERROR: ioffx={ioffx} is too large')
    if abs(ioffy) > naxis2:
        raise ValueError(f'ERROR: ioffy={ioffy} is too large')

    # compute intersection between the two images after accounting
    # for the relative offsets between them
    if ioffx <= 0:
        j1 = 0
        j2 = naxis1 + ioffx
        jj1 = -ioffx
        jj2 = naxis1
    else:
        j1 = ioffx
        j2 = naxis1
        jj1 = 0
        jj2 = naxis1 - ioffx

    if ioffy <= 0:
        i1 = 0
        i2 = naxis2 + ioffy
        ii1 = -ioffy
        ii2 = naxis2
    else:
        i1 = ioffy
        i2 = naxis2
        ii1 = 0
        ii2 = naxis2 - ioffy

    # define region where C.R. will be sought
    if list_skipped_regions is not None:
        mask_useful = np.ones((naxis2, naxis1), dtype=int)
        for region2d in list_skipped_regions:
            if isinstance(region2d, SliceRegion2D):
                mask_useful[region2d.python] = 0
            else:
                raise ValueError(f'Invalid item in list_skipped_regions: {region2d}')
    elif image_region is not None:
        mask_useful = np.zeros((naxis2, naxis1), dtype=int)
        if isinstance(image_region, SliceRegion2D):
            mask_useful[image_region.python] = 1
        else:
            raise ValueError(f'Invalid image_region: {image_region}')
    else:
        mask_useful = np.ones((naxis2, naxis1), dtype=int)

    if debug_level > 0:
        print('Computing overlaping rectangle:')
        print(f'ioffx: {ioffx}')
        print(f'ioffx: {ioffy}')
        print('data1:  i1,  i2,  j1,  j2: {}, {}, {}, {}'.format(i1, i2, j1, j2))
        print('data2: ii1, ii2, jj1, jj2: {}, {}, {}, {}'.format(ii1, ii2, jj1, jj2))

    # extract overlapping rectangular regions
    subdata1 = data1[i1:i2, j1:j2]
    subdata2 = data2[ii1:ii2, jj1:jj2]
    subuseful = mask_useful[i1:i2, j1:j2]

    shape1 = subdata1.shape
    shape2 = subdata2.shape
    if shape1 != shape2:
        raise ValueError('ERROR: overlapping regions have different shape')

    if maxsize is None:
        maxsize = shape1[0] * shape1[1]

    # difference between the two overlapping regions
    diff = subdata1 - subdata2
    if debug_level > 0:
        print(f'shape1: {shape1}, shape2: {shape2}, shape(diff): {diff.shape}')

    # statistical summary
    median = float(np.median(diff))
    std = robust_std(diff)
    if debug_level > 0:
        print('\n>>> Statistical summary of diff = overlapping data1 - data2:')
        print(f'>>> Median....: {median:.3f}')
        print(f'>>> Robust_std: {std:.3f}')

    # search for positive peaks (CR in data1)
    labels_pos_peak, no_cr_pos_peak = ndimage.label(diff > median + tsigma_peak * std)
    labels_pos_tail, no_cr_pos_tail = ndimage.label(diff > median + tsigma_tail * std)
    # set all CR peak pixels to 1
    mask_pos_peak = np.zeros_like(labels_pos_peak)
    mask_pos_peak[labels_pos_peak > 0] = 1
    # multiply peak and tail masks in order to find the intersection
    labels_pos_tail_in_peak = labels_pos_tail * mask_pos_peak * subuseful
    # define effective mask using tail mask of CR detected in peak mask
    mask_pos_clean = np.zeros_like(labels_pos_peak)
    for icr in np.unique(labels_pos_tail_in_peak):
        if icr > 0:
            npix_affected = np.sum(labels_pos_tail == icr)
            if npix_affected <= maxsize:
                mask_pos_clean[labels_pos_tail == icr] = 1
    # replace pixels affected by cosmic rays
    data1c = data1.copy()
    for item in np.argwhere(mask_pos_clean):
        data1c[item[0] + i1, item[1] + j1] = data2[item[0] + ii1, item[1] + jj1] + median

    if single_mode:
        data2c = data2.copy()
        mask_neg_clean = np.zeros_like(mask_pos_clean)
        labels_neg_peak = None
        labels_neg_tail = None
        labels_neg_tail_in_peak = None
        no_cr_neg_peak = 0
        no_cr_neg_tail = 0
    else:
        # search for negative peaks (CR in data2)
        labels_neg_peak, no_cr_neg_peak = ndimage.label(diff < median - tsigma_peak * std)
        labels_neg_tail, no_cr_neg_tail = ndimage.label(diff < median - tsigma_tail * std)
        # set all CR peak pixels to 1
        mask_neg_peak = np.zeros_like(labels_neg_peak)
        mask_neg_peak[labels_neg_peak > 0] = 1
        # multiply peak and tail masks in order to find the intersection
        labels_neg_tail_in_peak = labels_neg_tail * mask_neg_peak * subuseful
        # define effective mask using tail mask of CR detected in peak mask
        mask_neg_clean = np.zeros_like(labels_neg_peak)
        for icr in np.unique(labels_neg_tail_in_peak):
            if icr > 0:
                npix_affected = np.sum(labels_neg_tail == icr)
                if npix_affected <= maxsize:
                    mask_neg_clean[labels_neg_tail == icr] = 1
        # replace pixels affected by cosmic rays
        data2c = data2.copy()
        for item in np.argwhere(mask_neg_clean):
            data2c[item[0] + ii1, item[1] + jj1] = data1[item[0] + i1, item[1] + j1] - median

    # insert result in arrays with the original data shape
    mask_data1c = np.zeros((naxis2, naxis1), dtype=int)
    mask_data1c[i1:i2, j1:j2] = mask_pos_clean
    mask_data2c = np.zeros((naxis2, naxis1), dtype=int)
    mask_data2c[ii1:ii2, jj1:jj2] = mask_neg_clean

    # display intermediate results
    if debug_level > 0:
        if zoom_region_imshow is None:
            zoom_region_imshow = SliceRegion2D(np.s_[0:naxis2, 0:naxis1], mode='python')
        else:
            if isinstance(zoom_region_imshow, SliceRegion2D):
                pass
            else:
                raise ValueError(f'Object zoom_region_imshow={zoom_region_imshow} '
                                 f'of type {type(zoom_region_imshow)} is not a SliceRegion2D')
        if debug_level == 2:
            # display histogram
            hmin = max(min(diff.flatten()), median - 10*tsigma_peak*std)
            hmax = min(max(diff.flatten()), median + 10*tsigma_peak*std)
            bins = np.linspace(hmin, hmax, 100)
            fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(12, 6))
            ax.hist(diff[zoom_region_imshow.python].flatten(), bins=bins)
            ax.set_xlabel('ADU')
            ax.set_ylabel('Number of pixels')
            ax.set_title('diff: overlapping data1 - data2')
            ax.set_yscale('log')
            plt.show()
            # display diff
            fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(15, 15*naxis2/naxis1))
            vmin = median - tsigma_peak * std
            vmax = median + tsigma_peak * std
            tea_imshow(fig, ax, diff, vmin=vmin, vmax=vmax, cmap='seismic')
            ax.set_xlim([zoom_region_imshow.python[1].start, zoom_region_imshow.python[1].stop])
            ax.set_ylim([zoom_region_imshow.python[0].start, zoom_region_imshow.python[0].stop])
            ax.set_title('diff: overlapping data1 - data2')
            plt.tight_layout()
            plt.show()
        # display data and labels
        image_list1 = [
            data1, labels_pos_peak, labels_pos_tail, labels_pos_tail_in_peak, data1, data1c
        ]
        title_list1 = [
            'data1', 'labels_pos_peak', 'labels_pos_tail', 'labels_pos_tail_in_peak', 
            'data1 with C.R.', 'data1c'
        ]
        if debug_level == 1:
            del image_list1[1:4]
            del title_list1[1:4]
        if single_mode:
            image_list2 = None
            title_list2 = None
        else:
            image_list2 = [
                data2, labels_neg_peak, labels_neg_tail, labels_neg_tail_in_peak, data2, data2c
            ]
            title_list2 = [
                'data2', 'labels_neg_peak', 'labels_neg_tail', 'labels_neg_tail_in_peak', 
                'data2 with C.R.', 'data2c'
            ]
            if debug_level == 1:
                del image_list2[1:4]
                del title_list2[1:4]
        if single_mode:
            nblocks = 1
        else:
            nblocks = 2
        for iblock in range(nblocks):
            if iblock == 0:
                image_list = image_list1
                title_list = title_list1
                mask_datac = mask_data1c
                print(f'Number of CR in data1: {no_cr_pos_peak} peaks, {no_cr_pos_tail} tails')
            else:
                image_list = image_list2
                title_list = title_list2
                mask_datac = mask_data2c
                print(f'Number of CR in data2: {no_cr_neg_peak} peaks, {no_cr_neg_tail} tails')
            for iplot, (image, title) in enumerate(zip(image_list, title_list)):
                imgplot = image[zoom_region_imshow.python]
                naxis2_, naxis1_ = imgplot.shape
                fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(15, 15*naxis2_/naxis1_))
                median_ = np.median(imgplot)
                std_ = robust_std(imgplot)
                if std_ == 0:
                    vmin = imgplot.min()
                    vmax = imgplot.max()
                    cmap = 'gist_ncar'
                else:
                    vmin = median_ - 2 * std_
                    vmax = median_ + 5 * std_
                    cmap = 'gray'
                tea_imshow(fig, ax, image, vmin=vmin, vmax=vmax, cmap=cmap)
                ax.set_xlim([zoom_region_imshow.python[1].start, zoom_region_imshow.python[1].stop - 1])
                ax.set_ylim([zoom_region_imshow.python[0].start, zoom_region_imshow.python[0].stop - 1])
                ax.set_title(title)
                if title[-4:] == 'C.R.':
                    xyp = np.argwhere(mask_datac > 0)
                    xp = [item[1] for item in xyp]
                    yp = [item[0] for item in xyp]
                    ax.plot(xp, yp, 'r+')
                if 'data' in title:
                    if list_skipped_regions is not None:
                        for region2d in list_skipped_regions:
                            x1, x2 = region2d.python[1].start, region2d.python[1].stop - 1
                            y1, y2 = region2d.python[0].start, region2d.python[0].stop - 1
                            xwidth = x2 - x1
                            yheight = y2 - y1
                            if iblock == 1:
                                x1 = x1 - ioffx
                                y1 = y1 - ioffy
                            rect = patches.Rectangle((x1, y1), xwidth, yheight,
                                                     edgecolor='yellow', facecolor='none')
                            ax.add_patch(rect)
                    elif image_region is not None:
                        x1, x2 = image_region.python[1].start, image_region.python[1].stop - 1
                        y1, y2 = image_region.python[0].start, image_region.python[0].stop - 1
                        xwidth = x2 - x1
                        yheight = y2 - y1
                        if iblock == 1:
                            x1 = x1 - ioffx
                            y1 = y1 - ioffy
                        rect = patches.Rectangle((x1, y1), xwidth, yheight,
                                                 edgecolor='cyan', facecolor='none')
                        ax.add_patch(rect)
                plt.tight_layout()
                plt.show()

    if return_masks:
        return data1c, data2c, mask_data1c, mask_data2c
    else:
        return data1c, data2c


def apply_cr2images_ccddata(infile1, infile2=None, outfile1=None, outfile2=None,
                            ioffx=0, ioffy=0, tsigma_peak=10, tsigma_tail=3,
                            list_skipped_regions=None, image_region=None,
                            median_size=None, debug_level=0, zoom_region_imshow=None):
    """Apply cr2images() to FITS files storing CCDData.

    The FITS file must contain:
    - a primary HDU
    - extension1: MASK
    - extension2: UNCERT

    Parameters
    ----------
    infile1 : str
        Input file name corresponding to the first image.
    infile2 : str or None
        Input file name corresponding to the second image. If None,
        a median filtered version of the first image is employed.
        In this case, the parameter 'median_size' must be properly set.
    outfile1 : str
        Output file name of the cleaned version of the first image.
    outfile2 : str or None
        Output file name of the cleaned version of the second image
        (when a second input file is provided). Otherwise this parameter
        is ignored.
        ioffx : int
        Integer offset (pixels) to place the second image on top of
        the first image in the horizontal direction (axis=1) in the
        numpy array.
    ioffx : int
        Integer offset (pixels) to place the second image on top of
        the first image in the horizontal direction (axis=1) in the
        numpy array.
    ioffy : int
        Integer offset (pixels) to place the second image on top of
        the first image in the vertical direction (axis=0) in the
        numpy array.
    tsigma_peak : float
        Times sigma to detect cosmic ray peaks
    tsigma_tail : float
        Times sigma to detect additional pixels affected by cosmic
        rays.
    list_skipped_regions : list or None
        List of SliceRegion2D instances indicating image regions where
        detected cosmic rays will not be removed. The indices refer
        to the location of the regions in data1. This option is not
        compatible with image_region.
    image_region : SliceRegion2D instance or None
        Single instance of SliceRegion2D indicating the region where
        cosmic rays will be detected. The indices refer to the location
        of the region in data1. This option is not compatible
        with list_skipped_regions.
    median_size : tuple of integers
         Shape that is taken from the input array, at every element
         position, to compute the median filter. Note that the tuple
         order correspond to (Yaxis, Xaxis). This is only employed
         when 'data2' is None.
    debug_level : int
        If different from zero, print and display debugging information.
    zoom_region_imshow : SliceRegion2D instance or None
        If not None, display intermediate images, zooming in the
        indicated region.

    """

    if infile2 is None:
        if (ioffx != 0) or (ioffy != 0):
            raise ValueError(f'ERROR: ioffx={ioffx} and ioffy={ioffy} must be zero!')
        if median_size is None:
            raise ValueError(f'ERROR: you must specify median_size when only one image is available')

    history_list = ['using cr2images:']

    ccdimage1 = CCDData.read(infile1)
    ccdimage1_clean = ccdimage1.copy()

    if infile2 is not None:
        ccdimage2 = CCDData.read(infile2)
        ccdimage2_clean = ccdimage2.copy()
        ccdimage1_clean.data, ccdimage2_clean.data, mask_data1c, mask_data2c = cr2images(
            data1=ccdimage1.data,
            data2=ccdimage2.data,
            ioffx=ioffx,
            ioffy=ioffy,
            tsigma_peak=tsigma_peak,
            tsigma_tail=tsigma_tail,
            list_skipped_regions=list_skipped_regions,
            image_region=image_region,
            return_masks=True,
            debug_level=debug_level,
            zoom_region_imshow=zoom_region_imshow
        )
        ccdimage1_clean.mask[mask_data1c.astype(bool)] = True
        ccdimage2_clean.mask[mask_data2c.astype(bool)] = True
        ccdimage1_clean.uncertainty.array[ccdimage1_clean.mask] = \
            ccdimage2.uncertainty.array[ccdimage1_clean.mask]
        ccdimage2_clean.uncertainty.array[ccdimage2_clean.mask] = \
            ccdimage1.uncertainty.array[ccdimage2_clean.mask]
        history_list.append(f'- infile1: {Path(infile1).name}')
        history_list.append(f'- infile2: {Path(infile2).name}')
        history_list.append(f'- ioffx: {ioffx}')
        history_list.append(f'- ioffy: {ioffy}')
    else:
        ccdimage2_clean = None
        ccdimage1_clean.data, _, mask_data1c, _ = cr2images(
            data1=ccdimage1.data,
            median_size=median_size,
            tsigma_peak=tsigma_peak,
            tsigma_tail=tsigma_tail,
            list_skipped_regions=list_skipped_regions,
            image_region=image_region,
            return_masks=True,
            debug_level=debug_level,
            zoom_region_imshow=zoom_region_imshow
        )
        ccdimage1_clean.mask[mask_data1c.astype(bool)] = True
        ccdimage2_uncertainty_array = ndimage.median_filter(ccdimage1.uncertainty.array, size=median_size)
        ccdimage1_clean.uncertainty.array[ccdimage1_clean.mask] = \
            ccdimage2_uncertainty_array[ccdimage1_clean.mask]
        history_list.append(f'- infile1: {Path(infile1).name}')
        history_list.append('- infile2: None')
        history_list.append(f'- median_size: {median_size}')

    history_list.append(f'- tsigma_peak: {tsigma_peak}')
    history_list.append(f'- tsigma_tail: {tsigma_tail}')

    for outfile, ccdimage_clean in zip([outfile1, outfile2],
                                       [ccdimage1_clean, ccdimage2_clean]):
        if ccdimage_clean is not None:
            # update FILENAME keyword with output file name
            ccdimage_clean.header['FILENAME'] = Path(outfile).name

            # update HISTORY in header
            ccdimage_clean.header['HISTORY'] = '-------------------'
            ccdimage_clean.header['HISTORY'] = f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            for item in history_list:
                ccdimage_clean.header['HISTORY'] = item

            # save result
            ccdimage_clean.write(outfile, overwrite='yes')
            print(f'Output file name: {outfile}')


def crmedian(inputlist):
    """Remove cosmic rays by computing the median of a list of arrays.

    Parameters
    ----------
    inputlist : python list
        List of tuples with the necessary input data. Each tuple contains
        three items:
        - input numpy data array
        - offset in the X direction (integer value)
        - offset in the Y direction (integer value)

    Returns
    -------
    image2d : numpy masked array
        Median combination of the input arrays.

    """

    num_images = len(inputlist)

    # check number of images
    if num_images < 3:
        raise ValueError('input list must contain at least 3 images')

    # check array dimensions
    naxis2, naxis1 = inputlist[0][0].shape
    for k in range(1, num_images):
        naxis2_, naxis1_ = inputlist[k][0].shape
        if naxis2_ != naxis2 or naxis1_ != naxis1:
            raise ValueError(f'Image sizes are not identical: ({naxis1}, {naxis2}) != ({naxis1_}, {naxis2_})')

    # data cube to store all the data arrays
    image3d = ma.array(
        data=np.zeros((num_images, naxis2, naxis1), dtype=float),
        mask=np.ones((num_images, naxis2, naxis1), dtype=bool)
    )
    for k in range(num_images):
        data = inputlist[k][0]
        ioffx = inputlist[k][1]
        ioffy = inputlist[k][2]
        if ioffx <= 0:
            j1 = 0
            j2 = naxis1 + ioffx
            jj1 = -ioffx
            jj2 = naxis1
        else:
            j1 = ioffx
            j2 = naxis1
            jj1 = 0
            jj2 = naxis1 - ioffx

        if ioffy <= 0:
            i1 = 0
            i2 = naxis2 + ioffy
            ii1 = -ioffy
            ii2 = naxis2
        else:
            i1 = ioffy
            i2 = naxis2
            ii1 = 0
            ii2 = naxis2 - ioffy

        image3d.mask[k, i1:i2, j1:j2] = False
        image3d.data[k, i1:i2, j1:j2] = data[ii1:ii2, jj1:jj2]

    # compute median
    image2d = ma.median(image3d, axis=0)

    # return result
    return image2d
